<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet/less" type="text/css" href="/statics/style.less" />
    <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/3.9.0/less.min.js"></script>
    <title>Resource.rs - 旨在提供一站式的 Rust 学习资源</title>
</head>

<body>

    <header>
        <h1 style="font-size: 2.5rem;">100 行代码实现 Rust stack-less 的协程库<sup>ALPHA</sup></h1>
        <nav>
            <a class="normal" href="/"><span>首页</span></a>
            <a class="normal" href="/"><span>专题系列</span></a>
            <a class="normal" href="/about"><span>关于我们</span></a>
            <a class="normal" href="https://github.com/Kilerd/resource.rs" target="_blank"><span>GitHub</span></a>
        </nav>
    </header>
    <main class="body">
        <section class="article">
            
            <section class="article-body yue">
                <p><a href="https://www.rust-lang.org/">Rust</a> 1.39.0 稳定之后，基于 <a href="https://www.infoq.com/presentations/rust-2019/"><code>async/await</code> 语法</a>可以用低于 100 行代码实现一个非常基础和安全的<a href="https://en.wikipedia.org/wiki/Coroutine">协程</a>库。该实现是完全基于 <code>std</code> 的，同时也是 stack-less 的（换句话说是不依赖于独立的 CPU 栈）。</p>
<p>该基础的协程库包含了最基础的、无事件触发的 <code>yield</code> 实现，它可以中断当前协程的执行来让其他协程执行。我用了一种最简洁的例子来演示携程库的实现。</p>
<h2>Yielder</h2>
<p>我们用一个只含有简单二进制状态的 <code>Fib</code> 结构体来模拟协程。该结构体 <code>Fib</code> 有一个 <code>waiter</code> 方法，该方法用来创建一个等待(awaited)状态的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> 以便协程调用。</p>
<pre><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Poll, Context};

enum State {
    Halted,
    Running,
}

struct Fib {
    state: State,
}

impl Fib {
    fn waiter&lt;'a&gt;(&amp;'a mut self) -&gt; Waiter&lt;'a&gt; {
        Waiter { fib: self }
    }
}

struct Waiter&lt;'a&gt; {
    fib: &amp;'a mut Fib,
}

impl&lt;'a&gt; Future for Waiter&lt;'a&gt; {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt; {
        match self.fib.state {
            State::Halted =&gt; {
                self.fib.state = State::Running;
                Poll::Ready(())
            }
            State::Running =&gt; {
                self.fib.state = State::Halted;
                Poll::Pending
            }
        }
    }
}
</code></pre>
<h2>Executor</h2>
<p>执行器(Executor) 用 <code>Vec</code> 来储存未完成的 Future，每一个 Future 的状态都储存在堆上。作为最简单的实现，它仅支持在运行前添加 Future，而不能在执行时或者之后添加。 <code>push</code> 方法用来添加一个新的 Future 到队列中， <code>run</code>方法逐个执行队列中的 Future，直到所有都完成。</p>
<pre><code class="language-rust">use std::collections::VecDeque;

struct Executor {
    fibs: VecDeque&lt;Pin&lt;Box&lt;dyn Future&lt;Output=()&gt;&gt;&gt;&gt;,
}

impl Executor {
    fn new() -&gt; Self {
        Executor {
            fibs: VecDeque::new(),
        }
    }

    fn push&lt;C, F&gt;(&amp;mut self, closure: C)
    where
        F: Future&lt;Output=()&gt; + 'static,
        C: FnOnce(Fib) -&gt; F,
    {
        let fib = Fib { state: State::Running };
        self.fibs.push_back(Box::pin(closure(fib)));
    }

    fn run(&amp;mut self) {
        let waker = waker::create();
        let mut context = Context::from_waker(&amp;waker);

        while let Some(mut fib) = self.fibs.pop_front() {
            match fib.as_mut().poll(&amp;mut context) {
                Poll::Pending =&gt; {
                    self.fibs.push_back(fib);
                },
                Poll::Ready(()) =&gt; {},
            }
        }
    }
}
</code></pre>
<h2>Null Waker</h2>
<p>对于上面的 Executor 实现，我们还需要一个类似 <a href="https://github.com/whatisaphone/genawaiter">genawaiter</a>(<a href="https://github.com/whatisaphone/genawaiter/blob/master/src/waker.rs">代码链接</a>) 中用的 Null Waker。</p>
<blockquote>
<p>译者： 对于 Null Waker 这个词就不错翻译了，对于 Waker 的概念，在 Rust 中就是用于把「该 Future 可以从 await 状态被激活了」这个消息发送给 Executor 以便 Executor 执行 Future 的模块，即称为 Waker。简而言之便是唤醒 await 状态中的 Future。</p>
</blockquote>
<pre><code class="language-rust">use std::task::{RawWaker, RawWakerVTable, Waker},

pub fn create() -&gt; Waker {
    // Safety: The waker points to a vtable with functions that do nothing. Doing
    // nothing is memory-safe.
    unsafe { Waker::from_raw(RAW_WAKER) }
}

const RAW_WAKER: RawWaker = RawWaker::new(std::ptr::null(), &amp;VTABLE);
const VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake_by_ref, drop);

unsafe fn clone(_: *const ()) -&gt; RawWaker { RAW_WAKER }
unsafe fn wake(_: *const ()) { }
unsafe fn wake_by_ref(_: *const ()) { }
unsafe fn drop(_: *const ()) { }
</code></pre>
<h2>跑起来看看</h2>
<p>我们可以通过下面的代码来测试这个库：</p>
<pre><code class="language-rust">pub fn main() {
    let mut exec = Executor::new();

    for instance in 1..=3 {
        exec.push(move |mut fib| async move {
            println!(&quot;{} A&quot;, instance);
            fib.waiter().await;
            println!(&quot;{} B&quot;, instance);
            fib.waiter().await;
            println!(&quot;{} C&quot;, instance);
            fib.waiter().await;
            println!(&quot;{} D&quot;, instance);
        });
    }

    println!(&quot;Running&quot;);
    exec.run();
    println!(&quot;Done&quot;);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-rust">Running
1 A
2 A
3 A
1 B
2 B
3 B
1 C
2 C
3 C
1 D
2 D
3 D
Done
</code></pre>
<h2>性能表现</h2>
<p>在 <code>lto=true</code> 的编译条件和 Intel i7-7820X CPU 执行条件下，内部循环每一轮循环大概花费了 5 纳秒。</p>
<pre><code class="language-rust">pub fn bench() {
    let mut exec = Executor::new();

    for _ in 1..=2 {
        exec.push(move |mut fib| async move {
            for _ in 0..100_000_000 {
                fib.waiter().await;
            }
        });
    }

    println!(&quot;Running&quot;);
    exec.run();
    println!(&quot;Done&quot;);
}
</code></pre>
<h2>最后</h2>
<p>Rust <code>async/await</code> 的一个优点就是它不依赖于任何特定的运行时，因此如果你不满足于当前的任何运行时，你可以自由地实现自己的 Executor。</p>
<p>运行时的独立性也有其缺点。例如，我们在上文中编写的库并不兼容 <code>async-std</code> 这样的运行时。实际上，这份实现违背了 <code>Future</code> 的 <code>poll</code> 设计原理，因为我们假定 Future 处于 <code>Pending</code> 状态之后就始终处于 <code>Ready</code> 状态。</p>
<p>Combined uses of several run-times in a single program is possible but requires extra care (see Reddit discussion).
在一个程序中共同使用多个运行时是科兴的，但是需要<strong>格外小心</strong>（详情见 <a href="https://www.reddit.com/r/rust/comments/eagjyf/using_libraries_depending_on_different_async/">Reddit 讨论</a>）</p>

            </section>
        </section>
    </main>
    <footer>
        <p class="point"></p>
        <p><a href="https://github.com/Kilerd/resource.rs" class="normal"><span>我们期待你的加入...</span></a></p>
    </footer>

</body>
<script src="/statics/prism.js" type="text/javascript"></script>
</html>